---
title: "Updated Prostate Cancer Treatment Prediction Model"
output:
  html_notebook:
    toc: TRUE
    toc_float: TRUE
---

# Load packages

```{r}
library(tidyverse)
# library(mlr)
# library(stringi)
library(lubridate)
library(h2o)
library(gtsummary)
```

# Load data

```{r}
file_names_with_dir = dir('Z:/MUSIC/datasets/music_20190909/data/input', full.names = TRUE)
file_names = dir('Z:/MUSIC/datasets/music_20190909/data/input')
for(i in seq_along(file_names)) {
  # print (file)
  assign(paste0(stringr::str_sub(file_names[i],1,-5)), read_csv(file_names_with_dir[i]))
}

```

# Limit to eligible cohort

```{r}
# View(status)
dim(status)

## Patient count: 87374
status$patientid %>% unique %>% length()

# limit to patients who are actively followed or who have died
# 1 = actively followed
# 3 = deceased
# 6 = no known treatment
status = 
  status %>% filter(status %in% c(1,3,6))

## Patient count: 87370 -- 4 fewer patients
status$patientid %>% unique %>% length()

# limit to eligible patients
# View(demographics)
dim(demographics) # 87374
demographics = 
  demographics %>% filter(eligible==1)

## Patient count: 65948
dim(demographics)

# apply status rule to demographics by patientid
demographics =
  demographics %>% filter(patientid %in% status$patientid)

dim(demographics) # 65944
```

# Biopsy data

```{r}
dim(biopsies)

# names(biopsies)

# removed duplicated columns named "augmented"
biopsies = biopsies[,-grep('augmented', names(biopsies))]

# limit to those diagnosed with cancer
biopsies =
  biopsies %>% filter(bxcap==1)

biopsies %>% group_by(patientid) %>% summarize(number=n()) %>% summary

# select first date (among biopsies for pts diagnosed with cancer)
biopsies =
  biopsies %>%
  mutate(bxdate = mdy(bxdate)) %>% 
  group_by(patientid) %>% 
  arrange(bxdate) %>% 
  slice(1) %>%
  ungroup

complete_data =
  inner_join(demographics,biopsies,by='patientid')

## Patient count: 39720
dim(complete_data)

# define age based on biopsy date on which cancer was first diagnosed
complete_data = 
  complete_data %>% 
  mutate(dob=mdy(dob)) %>%
  mutate(age=as.numeric(difftime(bxdate,dob, units='days'))/365.25)

# brings in family history and race
complete_data = 
  left_join(complete_data, addldemographics)

## Patient count: 39720
dim(complete_data)

```

# Labs

```{r}
complete_data =
  labs %>%
    mutate(labdate=mdy(labdate)) %>% 
    filter(labtype==1) %>% 
    right_join(complete_data,.,by='patientid') %>% 
    mutate(date_diff = as.numeric(difftime(bxdate, labdate, units='days'))) %>% 
    group_by(patientid) %>% 
    filter(date_diff >=0) %>%
    filter(date_diff <= 1000) %>% 
    arrange(date_diff) %>% 
    slice(1) %>% 
    ungroup %>% 
    left_join(complete_data,.)

glimpse(complete_data)

## Patient count: 39720
dim(complete_data)

complete_data =
  complete_data %>% rename(psa = labvalue)
```

# Comorbidities

```{r}
complete_data = 
  comorbidities %>%
  mutate(comorbdate = mdy(comorbdate)) %>% 
  right_join(complete_data,.,by='patientid') %>% 
  mutate(comorb_date_diff = abs(as.numeric(difftime(bxdate, comorbdate, units='days')))) %>% 
  group_by(patientid) %>% 
  filter(comorb_date_diff <= 1000) %>% 
  arrange(comorb_date_diff) %>% 
  slice(1) %>% 
  ungroup %>%
  left_join(complete_data,.)

## Patient count: 39720
dim(complete_data)
```

# Stagings

```{r}
complete_data = 
  stagings %>%
  mutate(clinstgdate=mdy(clinstgdate)) %>% 
  right_join(complete_data,.,by='patientid') %>% 
  mutate(stage_date_diff = as.numeric(difftime(bxdate, clinstgdate, units='days'))) %>% 
  group_by(patientid) %>% 
  filter(stage_date_diff <= 0) %>% # stage must be on or after biopsy date
  filter(stage_date_diff >= -150) %>%  # stage date must be <= than 150 days after biopsy date because stage is not always entered in right away at the time of biopsy
  arrange(stage_date_diff) %>% 
  slice(1) %>% 
  ungroup %>%
  left_join(complete_data,.)


## Patient count: 39720
dim(complete_data)
```

# Check if data ranges make sense; remove extreme values for height/weight

```{r}
# quality control
complete_data %>% select(date_diff, comorb_date_diff, stage_date_diff) %>% summary

# remove 1 missing value for age
complete_data$age %>% summary
complete_data =
  complete_data %>% filter(!is.na(age))

# remove people with extreme heights/weights
complete_data = 
  complete_data %>% filter(hgt<90 & between(wgt,80,712))

dim(complete_data) # 38675
```

# Treatments

```{r}
treatments = 
  treatments %>% select(patientid,asdate,trttype,trtclass)

dim(treatments)
treatments$patientid %>% unique %>% length # 35601
# trtclass = 1 means "primary" treatment, but 7 means neoadjuvant
# if trttype = 2 and trtclass = 1, if another observation within 6 months, use the 2nd trttype as primary

treatments =
  treatments %>% mutate(asdate = mdy(asdate))

complete_data = 
  treatments %>%
    group_by(patientid) %>% 
    arrange(asdate) %>%
    mutate(date_diff = c(0,diff(asdate))) %>%
    ungroup %>% 
    filter(trtclass==1 | (trtclass == 2 & date_diff <= 180)) %>% 
    group_by(patientid,trtclass) %>% # there are several instances where a patient has 2 entries for trtclass == 1; we are choosing the first one
    arrange(asdate) %>% 
    slice(1) %>% 
    ungroup %>% 
    select(-asdate,-date_diff) %>% 
    spread(trtclass,trttype) %>% 
    mutate(primary_tx_num = ifelse(is.na(`2`), `1`,ifelse(`1`==2,`2`,`1`))) %>% 
    select(patientid,primary_tx_num) %>% 
    filter(primary_tx_num != 12) %>% 
    mutate(primary_tx = ifelse(primary_tx_num == 1,'Active_surveillance',NA)) %>% 
    mutate(primary_tx = ifelse(primary_tx_num == 2,'Androgen_deprivation_therapy',primary_tx)) %>% 
    mutate(primary_tx = ifelse(primary_tx_num %in% c(3,6),'Radiation',primary_tx)) %>% 
    mutate(primary_tx = ifelse(primary_tx_num == 10, 'Radical_prostatectomy',primary_tx)) %>% 
    mutate(primary_tx = ifelse(primary_tx_num == 11, 'Watchful_waiting',primary_tx)) %>%
    mutate(primary_tx = ifelse(is.na(primary_tx), 'Other',primary_tx)) %>% 
    select(patientid,primary_tx) %>% 
    inner_join(complete_data)

complete_data = 
  complete_data %>% filter(primary_tx != 'Other')

dim(complete_data) # 31047
```

# Limit data to last 2 years from the most recent biopsy

```{r}
#Most recent biopsy date: 2019-08-06
recent_bx <- complete_data %>% arrange(desc(bxdate)) %>% slice(1) %>% 
  pull(bxdate)

complete_data <- complete_data %>%
  mutate(recentbx_datediff = as.numeric(difftime(recent_bx, bxdate, units='days'))) %>% 
  filter(recentbx_datediff <= 730)

dim(complete_data) # 9106
```

# Limit data to selected variables

```{r}
complete_data_selectedvars =
  complete_data %>% 
  mutate(famhx = ifelse(famhx %in% c(1,3),'Yes','No')) %>% 
  mutate(black = ifelse(race == 1,'Yes','No')) %>% 
  mutate(age_rc = ifelse(age >= 89, 89, round(age))) %>% 
  filter(clinmstg == 1) %>% 
  select(bxdate, practice, primary_tx, age_rc, psa, bxgs, bxgs1, bxgs2, 
         totcores, poscores, wgt, mi,diabnocomp, diaborgdam) %>% 
  mutate(diab = ifelse(diabnocomp==1 | diaborgdam == 1,1,0)) %>% 
  select(-diabnocomp,-diaborgdam) %>% 
  mutate_at(vars(mi, diab),. %>% {ifelse(.==1,'Yes','No')}) %>% 
  filter(!is.na(bxgs) & !is.na(bxgs1) & !is.na(bxgs2))

# complete_data_selectedvars = complete_data_selectedvars %>% as.data.frame
# complete_data_selectedvars %>% class

complete_data_selectedvars =
  complete_data_selectedvars %>%
  mutate_if(is.character,as.factor)

dim(complete_data_selectedvars)
# 6420 13
```

# Initializing h2o
```{r}
h2o.init()
music_data = as.h2o(complete_data_selectedvars)
```

# Running the isolation forest model
```{r}
# Build an Isolation forest model
isofor_model <- h2o.isolationForest(training_frame = music_data, x = 4:13,
                             sample_rate = 0.1,
                             max_depth = 20,
                             ntrees = 1000)
```

# Calculate normalized anomaly score and mean length
```{r}
score = h2o.predict(isofor_model, music_data[, 4:13])
result_pred = as.vector(score$predict)
mean_length = as.vector(score$mean_length)
h2o.hist(score$mean_length, breaks = 20)
```
The predictions from the isolation forest return the mean_length. This is the average number of splits it took to isolate the record across all the decision trees in the forest. Records with a smaller mean_length are more likely to be anomalous since it takes fewer partitions of the data to isolate them.

The histogram of the mean_length shows that most people have a mean_length greater than 10. This means that it takes more than 10 splits on average to partition them.

# Defining anomalies using mean length
We will define an anomaly as anyone who's mean_length is less than 10 These were patients who were easier to isolate from the rest of the data.

```{r}
anomalies_ml = complete_data_selectedvars[as.vector(score$mean_length) < 10, ]
paste0("Number of Anomilies: ", nrow(anomalies_ml))
```

# Defining anomalies using normalized anomaly score
- redo by labeling top 20% of outliers
- build new model to predict outliers using random forest -> generate a tree diagram
- predict_contributions.H20Model - diff from variable importance; gives contribitions of each column to the prediction
- present in 1-2 weeks; see if we can get a relevant cutoff/threshold (when it should not display a bar plot)
- consider outputting an anomaly score in the shiny app (isolation forest can predict a new anomaly score)
- determine why each patient is abnormal using the predict_contributions score

```{r}
# Score limit to filter data anomalies.
scorelimit = round(quantile(result_pred, probs = .90), 4)

anomaly = ifelse(result_pred > scorelimit, 1, 0)

# Add row score at the beginning of dataset
complete_data_selectedvars_sc = cbind(anom_score = round(result_pred, 4),
                                      mean_length,
                                      anomaly,
                                      complete_data_selectedvars)

# Get data anomalies by filtering all data.
anomalies_sc = complete_data_selectedvars_sc[complete_data_selectedvars_sc$rowscore > scorelimit,]

summary(anomalies_sc)
```

# Feature frequencies
```{r}
feature_frequencies = as.data.frame(h2o.feature_frequencies(isofor_model, music_data[, 4:13]))

feature_frequencies = feature_frequencies %>% dplyr::rename_all(paste0, "_freq")
askmusic_nas = cbind(complete_data_selectedvars_sc, feature_frequencies)
askmusic_nas = askmusic_nas %>% arrange(desc(anom_score))
```

# Top 3 Frequencies and table summary
```{r}
feat = colnames(complete_data_selectedvars)[4:13]
top_freq = rep(NA, nrow(askmusic_nas))

for(i in 1:nrow(askmusic_nas)){
  freq = unlist(askmusic_nas[i, 17:26], use.names = FALSE)
  freq_ind = order(freq, decreasing = TRUE)[1:3]
  freq_ord = sort(freq, decreasing = TRUE)
  top_freq[i] = paste0(feat[freq_ind[1]], ": ", freq_ord[1], " | ",
                        feat[freq_ind[2]], ": ", freq_ord[2], " | ",
                        feat[freq_ind[3]], ": ", freq_ord[3])
}

askmusic_final = cbind(askmusic_nas, top_freq)
askmusic_gt = askmusic_final %>% select(age_rc:diab) %>% 
  tbl_summary()
askmusic_gt
```


# Write csv and save gtsummary
```{r}
write.csv(x = askmusic_final, file = "music_data_anom_20200730.csv")
gt::gtsave(as_gt(askmusic_gt), file = "askmusic_summarytb.png")
```

# Build random forest to predict anomaly score
```{r}
askmusic_h20 = as.h2o(askmusic_final)
askmusic_rf = h2o.randomForest(x = 7:16, y = "anom_score",
                            training_frame = askmusic_h20, nfolds = 10,
                            seed = 1234)
```

# Predict feature contributions - SHAP values
```{r}
contributions = h2o.predict_contributions(askmusic_rf, askmusic_h20)
```

# Top 3 positive direction contributions
```{r}
ctr = as.data.frame(contributions)

ctr_names = colnames(ctr)[1:10]
top_ctr = rep(NA, nrow(ctr))

for(i in 1:nrow(ctr)){
  ctr_row = unlist(ctr[i, 1:10], use.names = FALSE)
  ctr_ind = order(ctr_row, decreasing = TRUE)[1:3]
  ctr_ord = sort(ctr_row, decreasing = TRUE)
  top_ctr[i] = paste0(ctr_names[ctr_ind[1]], ", ", 
                        ctr_names[ctr_ind[2]], ", ", 
                        ctr_names[ctr_ind[3]])
}

ctr = ctr %>% select_all(list(~ paste0("contr_", .)))
askmusic_final_2 = cbind(askmusic_final, ctr, top_ctr)

```

# Write csv
```{r}
write.csv(x = askmusic_final_2, file = "music_data_anom_ctr_20200802.csv")
```

# Run random forest to predict primary treatment
```{r}
askmusic_tx_mod = h2o.randomForest(x = 4:13, y = "primary_tx",
                            training_frame = music_data,
                            seed = 1234,
                            ntrees = 1000)

perf = h2o.performance(askmusic_tx_mod)
perf
```

# Save isolation forest model as mojo
```{r}
mojo_destination <- h2o.download_mojo(isofor_model)
```

